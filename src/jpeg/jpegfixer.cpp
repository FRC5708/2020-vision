#include <iostream>
#include <vector>
#include <string.h>
/*

// Adapted by Team 5708 from https://gist.github.com/gbrl0chn/1b1c3a480da57042a8fb63185d2d7250

static const uint8_t huffman_table[] =
{
    0xFF, 0xC4, 0x01, 0xA2, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02,
    0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x01, 0x00, 0x03,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
    0x0A, 0x0B, 0x10, 0x00, 0x02, 0x01, 0x03, 0x03, 0x02, 0x04, 0x03, 0x05,
    0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7D, 0x01, 0x02, 0x03, 0x00, 0x04,
    0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22,
    0x71, 0x14, 0x32, 0x81, 0x91, 0xA1, 0x08, 0x23, 0x42, 0xB1, 0xC1, 0x15,
    0x52, 0xD1, 0xF0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0A, 0x16, 0x17,
    0x18, 0x19, 0x1A, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x34, 0x35, 0x36,
    0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A,
    0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65, 0x66,
    0x67, 0x68, 0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A,
    0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x92, 0x93, 0x94, 0x95,
    0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8,
    0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2,
    0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5,
    0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
    0xE8, 0xE9, 0xEA, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9,
    0xFA, 0x11, 0x00, 0x02, 0x01, 0x02, 0x04, 0x04, 0x03, 0x04, 0x07, 0x05,
    0x04, 0x04, 0x00, 0x01, 0x02, 0x77, 0x00, 0x01, 0x02, 0x03, 0x11, 0x04,
    0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22,
    0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xA1, 0xB1, 0xC1, 0x09, 0x23, 0x33,
    0x52, 0xF0, 0x15, 0x62, 0x72, 0xD1, 0x0A, 0x16, 0x24, 0x34, 0xE1, 0x25,
    0xF1, 0x17, 0x18, 0x19, 0x1A, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x35, 0x36,
    0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A,
    0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65, 0x66,
    0x67, 0x68, 0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A,
    0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x92, 0x93, 0x94,
    0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7,
    0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA,
    0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4,
    0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
    0xE8, 0xE9, 0xEA, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA
};


static size_t fmemcpy(uint8_t *dst, uint8_t **src, size_t n, size_t* bytes_read) {
    memcpy(dst, *src, n);
    *src       += n;
    *bytes_read += n;
    
    return n;
}

std::vector<uint8_t> fixJpeg(void* inData, size_t inDataSize) {

	std::vector<uint8_t> outData;
	// Hopefully 4096 is enough
	outData.reserve(inDataSize + 4096);
    //NSMutableData *imgData = [NSMutableData data];
    uint8_t *bytes_data = (uint8_t *)inData;
    uint8_t hdr[4];
    size_t  wlen;
    size_t  size;
    bool    has_dht = false;
    
    size_t bytes_read = 0;
    
    wlen = fmemcpy(hdr, &bytes_data, 2, &bytes_read);
    
    if (memcmp(hdr, "\xff\xd8", 2)) return {};
    
    //[imgData appendBytes: hdr length: wlen];
	outData.insert(outData.end(), hdr, hdr+wlen);
    
    while (! has_dht) {
        wlen = fmemcpy(hdr, &bytes_data, 4, &bytes_read);
        
        if      (hdr[0] != 0xff) return {};
        if      (hdr[1] == 0xc4) has_dht = true;
        else if (hdr[1] == 0xda) break;
        
        size = (hdr[2] << 8) | hdr[3];
        
        //[imgData appendBytes: hdr length: wlen];
		outData.insert(outData.end(), hdr, hdr+wlen);
        
        size_t   l      = size - 2;
        //uint8_t *ptmp   = malloc(l);
        
       // fmemcpy(ptmp, &bytes_data, l);
        //[imgData appendBytes: ptmp length: l];
        //free(ptmp);
		outData.insert(outData.end(), bytes_data, bytes_data + l);
		bytes_data += l;
		bytes_read += l;
    }
    
    
    if (!has_dht) {
        //[imgData appendBytes: huffman_table length: sizeof(huffman_table)];
		outData.insert(outData.end(), huffman_table, huffman_table + sizeof(huffman_table));
        //[imgData appendBytes: hdr length: wlen];
		outData.insert(outData.end(), hdr, hdr+wlen);
    }
    
    size_t bytes_rest = inDataSize - bytes_read;
    //[imgData appendBytes: bytes_data length: bytes_rest];
	outData.insert(outData.end(), bytes_data, bytes_data + bytes_rest);
    
    //return [NSData dataWithData: imgData];
	return outData;
}
*/
/*
#include <libavcodec/avcodec.h>

extern "C" {
    static int mjpeg2jpeg_filter(AVBitStreamFilterContext *bsfc,
                             AVCodecContext *avctx, const char *args,
                             uint8_t **poutbuf, int *poutbuf_size,
                             const uint8_t *buf, int buf_size,
                             int keyframe);

}

 fixJpeg(void* inData, size_t inDataSize) {

    AVCodecContext* ctx = avcodec_alloc_context3(nullptr);

    uint8_t *poutbuf;
    int poutbuf_size;

    mjpeg2jpeg_filter(nullptr, ctx, nullptr, &poutbuf, &poutbuf_size, inData, inDataSize, 0);

    
}*/


// Adapted by Team 5708 for use outside of Libav

/*
 * MJPEG/AVI1 to JPEG/JFIF bitstream format filter
 * Copyright (c) 2010 Adrian Daerr and Nicolas George
 *
 * This file is part of Libav.
 *
 * Libav is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * Libav is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with Libav; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

/*
 * Adapted from mjpeg2jpeg.c, with original copyright:
 * Paris 2010 Adrian Daerr, public domain
 */

#include <string.h>
#include <memory>


/* JPEG marker codes */
 typedef enum {
     /* start of frame */
     SOF0  = 0xc0,       /* baseline */
     SOF1  = 0xc1,       /* extended sequential, huffman */
     SOF2  = 0xc2,       /* progressive, huffman */
     SOF3  = 0xc3,       /* lossless, huffman */
 
     SOF5  = 0xc5,       /* differential sequential, huffman */
     SOF6  = 0xc6,       /* differential progressive, huffman */
     SOF7  = 0xc7,       /* differential lossless, huffman */
     JPG   = 0xc8,       /* reserved for JPEG extension */
     SOF9  = 0xc9,       /* extended sequential, arithmetic */
     SOF10 = 0xca,       /* progressive, arithmetic */
     SOF11 = 0xcb,       /* lossless, arithmetic */
 
     SOF13 = 0xcd,       /* differential sequential, arithmetic */
     SOF14 = 0xce,       /* differential progressive, arithmetic */
     SOF15 = 0xcf,       /* differential lossless, arithmetic */
 
     DHT   = 0xc4,       /* define huffman tables */
 
     DAC   = 0xcc,       /* define arithmetic-coding conditioning */
 
     /* restart with modulo 8 count "m" */
     RST0  = 0xd0,
     RST1  = 0xd1,
     RST2  = 0xd2,
     RST3  = 0xd3,
     RST4  = 0xd4,
     RST5  = 0xd5,
     RST6  = 0xd6,
     RST7  = 0xd7,
 
     SOI   = 0xd8,       /* start of image */
     EOI   = 0xd9,       /* end of image */
     SOS   = 0xda,       /* start of scan */
     DQT   = 0xdb,       /* define quantization tables */
     DNL   = 0xdc,       /* define number of lines */
     DRI   = 0xdd,       /* define restart interval */
     DHP   = 0xde,       /* define hierarchical progression */
     EXP   = 0xdf,       /* expand reference components */
 
     APP0  = 0xe0,
     APP1  = 0xe1,
     APP2  = 0xe2,
     APP3  = 0xe3,
     APP4  = 0xe4,
     APP5  = 0xe5,
     APP6  = 0xe6,
     APP7  = 0xe7,
     APP8  = 0xe8,
     APP9  = 0xe9,
     APP10 = 0xea,
     APP11 = 0xeb,
     APP12 = 0xec,
     APP13 = 0xed,
     APP14 = 0xee,
     APP15 = 0xef,
 
     JPG0  = 0xf0,
     JPG1  = 0xf1,
     JPG2  = 0xf2,
     JPG3  = 0xf3,
     JPG4  = 0xf4,
     JPG5  = 0xf5,
     JPG6  = 0xf6,
     SOF48 = 0xf7,       
     LSE   = 0xf8,       
     JPG9  = 0xf9,
     JPG10 = 0xfa,
     JPG11 = 0xfb,
     JPG12 = 0xfc,
     JPG13 = 0xfd,
 
     COM   = 0xfe,       /* comment */
 
     TEM   = 0x01,       /* temporary private use for arithmetic coding */
 
     /* 0x02 -> 0xbf reserved */
 } JPEG_MARKER;
 
 
 /* These are the sample quantization tables given in JPEG spec section K.1.
  * The spec says that the values given produce "good" quality, and
  * when divided by 2, "very good" quality.
  */
 const unsigned char std_luminance_quant_tbl[64] = {
     16,  11,  10,  16,  24,  40,  51,  61,
     12,  12,  14,  19,  26,  58,  60,  55,
     14,  13,  16,  24,  40,  57,  69,  56,
     14,  17,  22,  29,  51,  87,  80,  62,
     18,  22,  37,  56,  68, 109, 103,  77,
     24,  35,  55,  64,  81, 104, 113,  92,
     49,  64,  78,  87, 103, 121, 120, 101,
     72,  92,  95,  98, 112, 100, 103,  99
 };
 const unsigned char std_chrominance_quant_tbl[64] = {
     17,  18,  24,  47,  99,  99,  99,  99,
     18,  21,  26,  66,  99,  99,  99,  99,
     24,  26,  56,  99,  99,  99,  99,  99,
     47,  66,  99,  99,  99,  99,  99,  99,
     99,  99,  99,  99,  99,  99,  99,  99,
     99,  99,  99,  99,  99,  99,  99,  99,
     99,  99,  99,  99,  99,  99,  99,  99,
     99,  99,  99,  99,  99,  99,  99,  99
 };

 
 /* Set up the standard Huffman tables (cf. JPEG standard section K.3) */
 /* IMPORTANT: these are only valid for 8-bit data precision! */
 const uint8_t ff_mjpeg_bits_dc_luminance[17] =
 { /* 0-base */ 0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 };
 const uint8_t ff_mjpeg_val_dc[12] =
 { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };
 
 const uint8_t ff_mjpeg_bits_dc_chrominance[17] =
 { /* 0-base */ 0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 };
 
 const uint8_t ff_mjpeg_bits_ac_luminance[17] =
 { /* 0-base */ 0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d };
 const uint8_t ff_mjpeg_val_ac_luminance[] =
 { 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12,
   0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07,
   0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08,
   0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0,
   0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16,
   0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28,
   0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
   0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
   0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
   0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
   0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
   0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
   0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,
   0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
   0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6,
   0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5,
   0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4,
   0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2,
   0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea,
   0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,
   0xf9, 0xfa
 };

 const uint8_t ff_mjpeg_bits_ac_chrominance[17] =
 { /* 0-base */ 0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77 };
 
 const uint8_t ff_mjpeg_val_ac_chrominance[] =
 { 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21,
   0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71,
   0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91,
   0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0,
   0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34,
   0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26,
   0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38,
   0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
   0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
   0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
   0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
   0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
   0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96,
   0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5,
   0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4,
   0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3,
   0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2,
   0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda,
   0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9,
   0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,
   0xf9, 0xfa
 };

static const uint8_t jpeg_header[] = {
    0xff, 0xd8,                     // SOI
    0xff, 0xe0,                     // APP0
    0x00, 0x10,                     // APP0 header size (including
                                    // this field, but excluding preceding)
    0x4a, 0x46, 0x49, 0x46, 0x00,   // ID string 'JFIF\0'
    0x01, 0x01,                     // version
    0x00,                           // bits per type
    0x00, 0x00,                     // X density
    0x00, 0x00,                     // Y density
    0x00,                           // X thumbnail size
    0x00,                           // Y thumbnail size
};

static const int dht_segment_size = 420;
static const uint8_t dht_segment_head[] = { 0xFF, 0xC4, 0x01, 0xA2, 0x00 };
static const uint8_t dht_segment_frag[] = {
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
    0x0a, 0x0b, 0x01, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static uint8_t *append(uint8_t *buf, const uint8_t *src, int size)
{
    memcpy(buf, src, size);
    return buf + size;
}

static uint8_t *append_dht_segment(uint8_t *buf)
{
    buf = append(buf, dht_segment_head, sizeof(dht_segment_head));
    buf = append(buf, ff_mjpeg_bits_dc_luminance + 1, 16);
    buf = append(buf, dht_segment_frag, sizeof(dht_segment_frag));
    buf = append(buf, ff_mjpeg_val_dc, 12);
    *(buf++) = 0x10;
    buf = append(buf, ff_mjpeg_bits_ac_luminance + 1, 16);
    buf = append(buf, ff_mjpeg_val_ac_luminance, 162);
    *(buf++) = 0x11;
    buf = append(buf, ff_mjpeg_bits_ac_chrominance + 1, 16);
    buf = append(buf, ff_mjpeg_val_ac_chrominance, 162);
    return buf;
}

std::vector<uint8_t> fixJpeg(const void *inData, size_t buf_size)
{
    uint8_t* buf = (uint8_t* ) inData;

    int input_skip, output_size;
    uint8_t *out;

    if (buf_size < 12) {
        fprintf(stderr, "input is truncated\n");
        return {};
    }
    if (memcmp("AVI1", buf + 6, 4)) {
        fprintf(stderr, "input is not MJPEG/AVI1\n");
        return {};
    }
    input_skip = (buf[4] << 8) + buf[5] + 4;
    if (buf_size < input_skip) {
       fprintf(stderr, "input is truncated\n");
        return {};
    }
    output_size = buf_size - input_skip +
                  sizeof(jpeg_header) + dht_segment_size;

    std::vector<uint8_t> output(output_size);
   // output = out = av_malloc(output_size);
    //if (!output)
    //    return {};
    out = output.data();
    out = append(out, jpeg_header, sizeof(jpeg_header));
    out = append_dht_segment(out);
    out = append(out, buf + input_skip, buf_size - input_skip);
    //*poutbuf = output;
    //*poutbuf_size = output_size;
    return output;
}
